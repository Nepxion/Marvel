package com.nepxion.swing.context;

/**
 * <p>Title: Nepxion Swing</p>
 * <p>Description: Nepxion Swing Repository</p>
 * <p>Copyright: Copyright (c) 2010</p>
 * <p>Company: Nepxion</p>
 * @author Neptune
 * @email 1394997@qq.com
 * @version 1.0
 */

import java.net.URL;
import java.util.Properties;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.nepxion.swing.button.ButtonContext;
import com.nepxion.swing.chart.ChartConstants;
import com.nepxion.swing.chart.ChartContext;
import com.nepxion.swing.font.FontConstants;
import com.nepxion.swing.font.FontContext;
import com.nepxion.swing.icon.IconContext;
import com.nepxion.swing.lookandfeel.LookAndFeelManager;
import com.nepxion.swing.popupmenu.PopupMenuConstants;
import com.nepxion.swing.popupmenu.PopupMenuContext;
import com.nepxion.swing.style.framework.StyleContext;
import com.nepxion.swing.topic.TopicContext;
import com.nepxion.util.context.AbstractContextRegister;

public class UIContextRegister
	extends AbstractContextRegister implements UIContextConstants
{
	private static Log log = LogFactory.getLog(UIContextRegister.class);
		
	/**
	 * The instance of Properties.
	 */
	protected Properties properties;
	
	/**
	 * Registers the context by a properties of context file.
	 * The context file is a native file.
	 * @param codeBase the instance of URL
	 * @param properties the instance of Properties
	 */
	public void initializeContext(Properties properties)
	{
		this.properties = properties;
		
		log.info("---- UI Context Initialization Start ----");
		
		initStyle();
		initDecorated();
		initFont();
		initPDF();
		initButtonUI();
		initPopupMenuTitle();
		initIconPath();
		initTopicComponent();		
		initLookAndFeel();
		
		log.info("----- UI Context Initialization End -----");
	}
	
	/**
	 * Registers the context by an url and properties of context file.
	 * The context file is a remote file.
	 * @param codeBase the instance of URL
	 * @param properties the instance of Properties
	 */
	public void initializeContext(URL codeBase, Properties properties)
	{
		initializeContext(properties);
	}
	
	/**
	 * Initializes the framework style config.
	 * The style values are configured in ui.properties.
	 * If the style config is null, the register will choose the custom style config.
	 * The provided style includes JLiteStyle, JWindowsStyle, JEclipseStyle, JPlasticStyle, JFervencyStyle, JNimbusStyle.
	 * If you want to set another style, you can implement IStyle or extend AbstractStyle, then set "style" as null and "customStyle" as your definition (the value is the full class path).
	 * If the style and custom style value are all null, the style value will generated by the look and feel configured. 
	 */
	private void initStyle()
	{		
		String style = properties.getProperty("style");
		String customStyle = properties.getProperty("customStyle");
		if (!isValid(style) && !isValid(customStyle))
		{
			style = DEFAULT_STYLE;
		}
		
		if (isValid(style))
		{
			style = DEFAULT_FRAMEWORK_STYLE_PACKAGE + "." + style;
		}
		
		if (isValid(style))
		{
			StyleContext.registerStyle(style);
		}
		else if (isValid(customStyle))
		{
			StyleContext.registerStyle(customStyle);
		}
		
		log.info("Parameter - style : [" + style + "]");
		log.info("Parameter - customStyle : [" + customStyle + "]");
	}
	
	/**
	 * Initializes the decorated config.
	 * The decorated values are configured in ui.properties.
	 * The decorated config includes frameDecorated and dialogDecorated.
	 * The frameDecorated means that JFrame will be decorated by JVM (Not by OS). The default value is false (decorated by OS).
	 * The dialogDecorated means that JDialog will be decorated by JVM (Not by OS). The default value is false (decorated by OS).
	 */
	private void initDecorated()
	{
		String frameDecorated = properties.getProperty("frameDecorated");
		String dialogDecorated = properties.getProperty("dialogDecorated");
		
		boolean isFrameDecorated = false;
		boolean isDialogDecorated = false;
		
		if (isValid(frameDecorated))
		{
			isFrameDecorated = frameDecorated.equals("true");
		}
		
		if (isValid(dialogDecorated))
		{
			isDialogDecorated = dialogDecorated.equals("true");
		}
		
		StyleContext.registerFrameDecorated(isFrameDecorated);
		StyleContext.registerDialogDecorated(isDialogDecorated);
		
		log.info("Parameter - isFrameDecorated : [" + isFrameDecorated + "]");
		log.info("Parameter - isDialogDecorated : [" + isDialogDecorated + "]");
	}
	
	/**
	 * Initializes the font config.
	 * The font values are configured in ui.properties.
	 * The font config includes all of common fonts and chart fonts.
	 */
	private void initFont()
	{		
		String fontName = properties.getProperty("fontName");
		int fontStyle = -1;
		int fontSize = -1;
		
		if (!isValid(fontName))
		{
			fontName = FontConstants.DEFAULT_FONT_NAME;
		}
		try
		{
			fontStyle = Integer.parseInt(properties.getProperty("fontStyle"));
			fontSize = Integer.parseInt(properties.getProperty("fontSize"));
		}
		catch (Exception e)
		{
			fontStyle = FontConstants.DEFAULT_FONT_STYLE;
			fontSize = FontConstants.DEFAULT_FONT_SIZE;
		}
		
		String chartTitleFontName = properties.getProperty("chartTitleFontName");
		int chartTitleFontStyle = -1;
		int chartTitleFontSize = -1;
		
		if (!isValid(chartTitleFontName))
		{
			chartTitleFontName = FontConstants.DEFAULT_CHART_TITLE_FONT_NAME;
		}
		try
		{
			chartTitleFontStyle = Integer.parseInt(properties.getProperty("chartTitleFontStyle"));
			chartTitleFontSize = Integer.parseInt(properties.getProperty("chartTitleFontSize"));
		}
		catch (Exception e)
		{
			chartTitleFontStyle = FontConstants.DEFAULT_CHART_TITLE_FONT_STYLE;
			chartTitleFontSize = FontConstants.DEFAULT_CHART_TITLE_FONT_SIZE;
		}
		
		String chartSubTitleFontName = properties.getProperty("chartSubTitleFontName");
		int chartSubTitleFontStyle = -1;
		int chartSubTitleFontSize = -1;
		
		if (!isValid(chartSubTitleFontName))
		{
			chartSubTitleFontName = FontConstants.DEFAULT_CHART_SUB_TITLE_FONT_NAME;
		}
		try
		{
			chartSubTitleFontStyle = Integer.parseInt(properties.getProperty("chartSubTitleFontStyle"));
			chartSubTitleFontSize = Integer.parseInt(properties.getProperty("chartSubTitleFontSize"));
		}
		catch (Exception e)
		{
			chartSubTitleFontStyle = FontConstants.DEFAULT_CHART_SUB_TITLE_FONT_STYLE;
			chartSubTitleFontSize = FontConstants.DEFAULT_CHART_SUB_TITLE_FONT_SIZE;
		}
		
		String chartLabelFontName = properties.getProperty("chartLabelFontName");
		int chartLabelFontStyle = -1;
		int chartLabelFontSize = -1;
		
		if (!isValid(chartLabelFontName))
		{
			chartLabelFontName = FontConstants.DEFAULT_CHART_LABEL_FONT_NAME;
		}
		try
		{
			chartLabelFontStyle = Integer.parseInt(properties.getProperty("chartLabelFontStyle"));
			chartLabelFontSize = Integer.parseInt(properties.getProperty("chartLabelFontSize"));
		}
		catch (Exception e)
		{
			chartLabelFontStyle = FontConstants.DEFAULT_CHART_LABEL_FONT_STYLE;
			chartLabelFontSize = FontConstants.DEFAULT_CHART_LABEL_FONT_SIZE;
		}
		
		String chartTickLabelFontName = properties.getProperty("chartTickLabelFontName");
		int chartTickLabelFontStyle = -1;
		int chartTickLabelFontSize = -1;
		
		if (!isValid(chartTickLabelFontName))
		{
			chartTickLabelFontName = FontConstants.DEFAULT_CHART_TICK_LABEL_FONT_NAME;
		}
		try
		{
			chartTickLabelFontStyle = Integer.parseInt(properties.getProperty("chartTickLabelFontStyle"));
			chartTickLabelFontSize = Integer.parseInt(properties.getProperty("chartTickLabelFontSize"));
		}
		catch (Exception e)
		{
			chartTickLabelFontStyle = FontConstants.DEFAULT_CHART_TICK_LABEL_FONT_STYLE;
			chartTickLabelFontSize = FontConstants.DEFAULT_CHART_TICK_LABEL_FONT_SIZE;
		}
		
		FontContext.registerFont(fontName, fontStyle, fontSize);
		FontContext.registerChartTitleFont(chartTitleFontName, chartTitleFontStyle, chartTitleFontSize);
		FontContext.registerChartSubTitleFont(chartSubTitleFontName, chartSubTitleFontStyle, chartSubTitleFontSize);
		FontContext.registerChartLabelFont(chartLabelFontName, chartLabelFontStyle, chartLabelFontSize);
		FontContext.registerChartTickLabelFont(chartTickLabelFontName, chartTickLabelFontStyle, chartTickLabelFontSize);
		
		log.info("Parameter - fontName : [" + fontName + "]");
		log.info("Parameter - fontStyle : [" + fontStyle + "]");
		log.info("Parameter - fontSize : [" + fontSize + "]");			
		log.info("Parameter - chartTitleFontName : [" + chartTitleFontName + "]");
		log.info("Parameter - chartTitleFontStyle : [" + chartTitleFontStyle + "]");
		log.info("Parameter - chartTitleFontSize : [" + chartTitleFontSize + "]");			
		log.info("Parameter - chartSubTitleFontName : [" + chartSubTitleFontName + "]");
		log.info("Parameter - chartSubTitleFontStyle : [" + chartSubTitleFontStyle + "]");
		log.info("Parameter - chartSubTitleFontSize : [" + chartSubTitleFontSize + "]");			
		log.info("Parameter - chartLabelFontName : [" + chartLabelFontName + "]");
		log.info("Parameter - chartLabelFontStyle : [" + chartLabelFontStyle + "]");
		log.info("Parameter - chartLabelFontSize : [" + chartLabelFontSize + "]");
		log.info("Parameter - chartTickLabelFontName : [" + chartTickLabelFontName + "]");
		log.info("Parameter - chartTickLabelFontStyle : [" + chartTickLabelFontStyle + "]");
		log.info("Parameter - chartTickLabelFontSize : [" + chartTickLabelFontSize + "]");
	}
	
	/**
	 * Initializes the pdf config.
	 * The pdf values are configured in ui.properties.
	 * The pdf config includes the chart pdf author and subject.
	 */
	private void initPDF()
	{
		String chartPDFAuthor = properties.getProperty("chartPDFAuthor");
		if (!isValid(chartPDFAuthor))
		{
			chartPDFAuthor = ChartConstants.DEFAULT_CHART_PDF_AUTHOR;
		}
		
		String chartPDFSubject = properties.getProperty("chartPDFSubject");
		if (!isValid(chartPDFSubject))
		{
			chartPDFSubject = ChartConstants.DEFAULT_CHART_PDF_SUBJECT;
		}
		
		ChartContext.registerChartPDFAuthor(chartPDFAuthor);
		ChartContext.registerChartPDFSubject(chartPDFSubject);
		
		log.info("Parameter - chartPDFAuthor : [" + chartPDFAuthor + "]");
		log.info("Parameter - chartPDFSubject : [" + chartPDFSubject + "]");
	}
	
	/**
	 * Initializes the button ui and style config.
	 * The button ui and style values are configured in ui.properties.
	 * If the button ui and style config are null, the register will choose the custom button ui and style config.
	 * The provided button ui includes FlatButtonUI, LiteButtonUI.
	 * The provided button style includes JFlatButtonStyle, JAlloyLiteButtonStyle, JAcidLiteButtonStyle, JBedouinLiteButtonStyle, JGlassLiteButtonStyle, JEclipseLiteButtonStyle,  
	 * JNimbusLiteButtonStyle, JBorlandLiteButtonStyle, JBlueLiteButtonStyle, JYellowLiteButtonStyle.
	 * If you want to set another button ui, you can implement IButtonUI or extend AbstractButtonUI, then set "buttonUI" as null and "customButtonUI" as your definition (the value is the full class path).
	 * If you want to set another button style, you can implement IButtonStyle, then set "buttonStyle" as null and "customButtonStyle" as your definition (the value is the full class path).
	 * If the button ui, button style, custom button ui and custom button style value are all null, the button ui and style value will generated by the look and feel configured. 
	 */
	private void initButtonUI()
	{		
		String buttonUI = properties.getProperty("buttonUI");       // Example : "LiteButtonUI";	
		String buttonStyle = properties.getProperty("buttonStyle"); // Example : "JAlloyLiteButtonStyle";
		
		String customButtonUI = properties.getProperty("customButtonUI");       // Example : "com.nepxion.swing.style.button.lite.LiteButtonUI";	 
		String customButtonStyle = properties.getProperty("customButtonStyle"); // Example : "com.nepxion.swing.style.button.lite.JAlloyLiteButtonStyle";
		
		if (isValid(buttonUI))
		{
			String buttonUIPrefix = ButtonContext.getButtonUIClassPrefix(buttonUI);
			buttonUI = DEFAULT_BUTTON_STYLE_PACKAGE + "." + buttonUIPrefix.toLowerCase() + "." + buttonUIPrefix + "ButtonUI";
			
			if (isValid(buttonStyle))
			{
				buttonStyle = DEFAULT_BUTTON_STYLE_PACKAGE + "." + buttonUIPrefix.toLowerCase() + "." + buttonStyle;
			}
		}
		else if (isValid(customButtonUI))
		{
			if (isValid(buttonStyle))
			{
				throw new IllegalArgumentException("It can't be specified ButtonStyle for '" + buttonStyle + "' when using custom ButtonUI");
			}
			else if (isValid(customButtonStyle))
			{
				String buttonUIPrefix = ButtonContext.getButtonUIClassPrefix(customButtonUI);
				
				customButtonUI = buttonUIPrefix + "ButtonUI";
			}
		}
		
		if (buttonUI != null)
		{	
			ButtonContext.registerUI(buttonUI, buttonStyle != null ? buttonStyle : customButtonStyle);
		}
		else if (customButtonUI != null)
		{
			ButtonContext.registerUI(customButtonUI, buttonStyle != null ? buttonStyle : customButtonStyle);
		}
		
		log.info("Parameter - buttonUI : [" + buttonUI + "]");
		log.info("Parameter - buttonStyle : [" + buttonStyle + "]");
		log.info("Parameter - customButtonUI : [" + customButtonUI + "]");
		log.info("Parameter - customButtonStyle : [" + customButtonStyle + "]");
	}
	
	/**
	 * Initializes the popup menu title config.
	 * The popup menu title value is configured in ui.properties.
	 */
	private void initPopupMenuTitle()
	{
		String popupMenuTitle = properties.getProperty("popupMenuTitle");
		if (!isValid(popupMenuTitle))
		{
			popupMenuTitle = PopupMenuConstants.DEFAULT_TITLE;
		}
		
		PopupMenuContext.registerTitle(popupMenuTitle);
		
		log.info("Parameter - popupMenuTitle : [" + popupMenuTitle + "]");
	}
	 
	/**
	 * Initializes the icon path config.
	 * The icon path value is configured in ui.properties.
	 * If configured, you should get the icon object by IconFactory.getContextIcon(iconName) and it will locate icon on the the icon path configured.
	 */
	private void initIconPath()
	{
		String iconPath = properties.getProperty("iconPath");
		if (!isValid(iconPath))
		{
			iconPath = DEFAULT_ICON_PATH;
		}
		
		IconContext.registerIconFolder(iconPath);
		
		log.info("Parameter - iconPath : [" + iconPath + "]");
	}
	
	/**
	 * Initializes the help topic component config.
	 * The help topic component value is configured in ui.properties.
	 * The value is the full class path.
	 */
	private void initTopicComponent()
	{
		String topicComponent = properties.getProperty("topicComponent");
		
		TopicContext.registerTopicComponent(topicComponent);
		
		log.info("Parameter - topicComponent : [" + topicComponent + "]");
	}
	
	/**
	 * Initializes the look and feel config.
	 * The look and feel values are configured in ui.properties.
	 * If the look and feel config is null, the register will choose the custom look and feel config.
	 * The provided look and feel includes SystemLookAndFeel, DefaultMetalLookAndFeel, MetalLookAndFeel, WindowsLookAndFeel, MotifLookAndFeel, GTKLookAndFeel, 
	 * NimbusLookAndFeel, AlloyLookAndFeel, AcidLookAndFeel, BedouinLookAndFeel, GlassLookAndFeel, BorlandLookAndFeel, 
	 * JGoodiesWindowsLookAndFeel, PlasticLookAndFeel, PlasticXPLookAndFeel, Plastic3DLookAndFeel, XPLookAndFeel, TinyLookAndFeel.
	 * If you want to set another look and feel, you can set "lookAndFeel" as null and "customLookAndFeel" as your wanted (the value is the full class path).
	 * If the look and feel and custom look and feel are all null, it will choose the default value for "SystemLookAndFeel".
	 */
	private void initLookAndFeel()
	{
		String lookAndFeel = properties.getProperty("lookAndFeel");
		String customLookAndFeel = properties.getProperty("customLookAndFeel");
		if (!isValid(lookAndFeel) && !isValid(customLookAndFeel))
		{
			lookAndFeel = DEFAULT_LOOK_ADN_FEEL;
		}
		
		if (isValid(lookAndFeel))
		{
			LookAndFeelManager.invokeLookAndFeel(lookAndFeel);
		}
		else if (isValid(customLookAndFeel))
		{
			LookAndFeelManager.setLookAndFeel(customLookAndFeel);
		}
		
		log.info("Parameter - lookAndFeel : [" + lookAndFeel + "]");
		log.info("Parameter - customLookAndFeel : [" + customLookAndFeel + "]");
	}
	
	/**
	 * Returns true if the content is valid.
	 * @param content the string
	 * @return true if the content is valid
	 */
	public boolean isValid(String content)
	{
		return content != null && !content.trim().equals("");
	}
}